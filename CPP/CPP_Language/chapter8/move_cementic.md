# 깊은 복사의 단점
- 문자열의 길이가 길어지면 또는 객체의 크기가 커졌을 때 많은 양의 연산을 수행해야하는 문제가 발생

- 복사생성자가 호출되는 이유를 알기 위해서는 임시객체에 대한 이해가 필요

### 임시객체
- 필요성으로 이해 컴파일러가 만드는 임시 메모리 공간
```cpp
int A(int a){
  cout << "A" << endl;
  return a;
}
```
- main 함수에서 A에 n을 인자로 넘겨주면 A라는 scope 에서만 사용 가능한 int a라는 임시 객체를 생성하게 된다, 임시객체 a는 n의 값을 담고 이때 복사가 일어나게 된다(값에 대한 복사)
그리고 return a 를 할 때도, 리턴값은 int형 임시객체를 생성하고 담게 된다
- 함수를 선언 할 때 int & A()를 사용해 임시객체를 만들지 말라고 의도할 수 있다
- 임시객체는 성능저하를 유발하기 때문에 참조에 의한 복사를 해주는 것이 좋음

# 1. 함수에서의 임시객체
```cpp
String getName(){
  String res = "Heun"
  return res;
}
String name1;
name1=getName();
```
- getName이 소멸될 때 리턴되는 값을 받는 변수가 필요한데
그때 생성되는게 위에서 정리한 임시객체.
- res는 사라지지만 이름이없는 임시객체가 메모리 어딘가에 살아있고 a 에 그 임시 객체가 들어가는 것이다
- s5=getName()을 할때 복사 대입연산자와 복사생성자가 호출되면서 깊은복사가 두번 일어난다.
- res가 임시객체로 복사되면서 1번, a에 그 임시객체가 복사되면서 깊은복사 1번더

# 2. 얕은복사로 해결
- 두번의 복사과정을 모두 얕은 복사로해결
- 얕은 복사하면 메모리 해제 두번시도하니까 이미 해제한 곳의 메모리에 접근해서 해제하려는 문제점을 해결해야함.
- 얕은 복사를 하되, 소멸자를 한번만 호출하게끔 하는것이 이동시맨틱.
- res를 가리키는 data를 임시객체에 복사생성자를 이용해 넣는게 아니라   
깊은 복사를 하지말고 res의 data가 가리키는 것을 끊고 임시객체의 data가 그곳을 가리키면 됨(주소값 복사)

# 3. 이동 생성자
- 그러면 매개변수를 r-value 로 가져와야 하는데 &&로 표현
res의 data가 가리키는 문자열을 임시객체의 data가 가리키고, res의 데이터를 끊어줌
```cpp
// 복사를 받아올 임시 객체인듯하다
String(String &&rhs){
  len = rhs.len;
  // 복사받을 객체의 데이터를 가져옴
  starData = rhs.strData;
  // rhs(원본)이 삭제되기전에 원본의 주소를 data를 null로 , rhs는 delete되어도 값을 넘겨놨으니 괜찮다 
  rhs.strData = Null;
}
```
- 소멸자 호출 전에 res의 strData가 아무것도 가리키지 않게 설정해놓으면 소멸자가 호출해도 res랑 NULL만 소멸하기 때문에 임시객체의 data는 멀쩡하게 문자열을 잘 가리킬 수 있다. 