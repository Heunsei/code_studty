# 연속된 자료 구조와 연결된 자료 구조
## 1. 연속된 자료구조
- 모든 원소를 단일 메모리 chunk에 저장한다, 원소들은 모두 같은 타입을 사용 
첫 메모리 주소를 시작 주소(BA)라 칭하고 두번 째 원소의 위치는 BA + sizeof(type)이다, i 번째 원소에 접근하려면 BA + i + sizeof(type)사용

- 배열의 유형엔 크게 정적 배열과, 동적 배열이 존재한다. 정적 배열은 선언된 블록이 끝나면 소멸되지만
동적 배열은 생성 시점과 해제 시점을 자유롭게 결정 가능.

### 1. 정적 배열은 int arr[size]; 의 형태로 나타냄
### 2. C에서 동적 배열은 int* arr = (int*)malloc(size * sizeof(int)); 형태로 선언
### 3. cpp에서 동적 배열은 int* arr = new int[size];로 선언

- 정적 배열은 스택 메모리에 할당 -> 함수를 벗어나면 자동으로 해제
- 동적 배열은 힙 메모리에 할당 -> 사용자가 직접 해제하기 전 까지 유지
- 캐시 지역성, 하나의 원소에 접근할 때, 그 옆에 있는 원소 몇개도 캐시로 가져옴

## 2. 연결된 자료구조
- 연결된 자료구조는 node라 하는 여러개의 청크에 데이터를 저장, 연결 리스트의 기본 구조에서 각각의 노드는 저장할 데이터와 다음 노드를 가르키는 포인터를 가지고 있음. 맨 마지막 노드는 자료의 끝을 나타내는 NULL을 가짐.

- 특정 원소에 접근 하려면 head부분 부터 next포인터를 따라 이동해야함
원소 접근 시간은 노드 개수에 비례하며 시간 복잡도로 O(n)

- 연결 리스트에서 새 원소를 추가 하려면 각 node의 next포인터를 수정해야함
원소가 메모리에 연속적으로 저장된 것이 아니라서 캐시 지역성을 기대하긴 힘듬

## 3. std :: array
```bash
# 크기가 10인 int 타입 배열
std::array<int, 10> arr1;

arr1[0] = 1;
std::cout << "arr1 배열의 첫 원소 : " << arr1[0] << std::endl;

std::arrt<int, 4> arr2 = {1, 2, 3, 4};
std::cout << "arr2의 모든 원소";

for(int i = 0 ; i < arr2.size(); i++)
{
    std::cout << arr2[i] << " ";
}
std::cout << std::endl;

# 출력>> arr1 배열의 첫 번쨰 원소 : 1 ;
# 출력>> arr2의 모든 원소 : 1 2 3 4  
# [] 연산자 또는 .at(offset)으로 원소 접근 가능

# 배열을 차례대로 접근하는 경우, 
std::arr<int, 5> arr3 = {1, 3, 5, 7, 9};
for(auto element : arr3)
    std::cout << element <<' ';

for(auto it = arr.begin(); it != arr.end(), it++)
{
    auto element =(*it);
    std::cout << element << ' ';
}
```