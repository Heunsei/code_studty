# 순열을 만드는 코드
```python
def f(i, N):
    if i == N:  # 순열 완성
        print(p)
        return
    else:   # p[i]에 들어갈 숫자를 결정
        for j in range(N):
            if used[j] == 0:  # 아직 사용하지 않은 카드면
                p[i] = card[j]
                used[j] = 1
                f(i+1, N)
                used[j] = 0

card = list(map(int, input()))
used = [0] * 6  # 이미 사용한 카드인지 표시
```
# 바이너리 카운팅
```python
a= [3,6,7,1,5,4]
N = 6
for i in range(1<<N):
    subset1 = []
    for j in range(N):
            if i&(1<<j): # j번 비트가 0이 아니면
                subset1.append(a[j])
    print(*subset1)
```

# 배낭 짐싸기
- Knapsack 문제의 정형적 정의
1. S = {} 물건들의 집합
2. w = item의 값
3. W :배낭이 수용가능한 총 무게
- 두가지 유형이 존재
1. 배낭에 물건을 통째로 담아야 하는 문제
    - 물건을 쪼갤 수 없는 경우
    - 값이 비싼 물건부터 채운다 > 최적이 아님
    - 가벼운거부터 담는다 > 최적이 아님
    - kg당 값이 높은 순서로 채운다 > 최적이 아님
    - 결국 부분집합 문제    

2. 물건을 부분적으로 담는 것이 허용되는 문제.
    - 물건을 쪼갤 수 있는 경우
    - 가치가 높은거부터 담고
    - 자리가 모자르면 잘라서 넣어주면 된다
    
# 활동 선택 문제
- 회의실을 배정하는 문제
- 시작시간과 종료시간이 주어졌을 때 활동시간 정하기
    1. 종료시간이 빠른 순서로 활동을 정렬
    2. 첫 번째 활동을 선택
    3. 선택한 활동의 종료시간보다 빠른 시작 시간을 가지는 활동을 제거
    4. 앞의 과정을 반복
    
# 고려해야할 상황
- 탐욕적 선택 속성
    - 탐욕적 선택은 최적해로 갈 수 있음을 보여야 한다
- 최적 부분 구조
  - 최적화 문제를 정형화 해야함
    > 하나를 선택을 하면 하나의 하위 문제가 남는다
    > 
# 탐욕 기법과 동적 계획법의 비교
- 탐욕기법
    1. 매 단계에서 가장 좋게 보이는 것을 선택
    2. 하위 문제를 풀기 전에 선택이 먼저 주어짐
    3. Top-down방식
    4. 일반적으로 빠르고 간결함
- DP
    1. 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 함
    2. 하위 문제가 우선 해결
    3. Bottom-up 방식
    4. 좀더 느라고 복잡함
    
# 탐욕기법 알고리즘
- Prim
- Kruskal
- Huffman tree & code